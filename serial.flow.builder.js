(function () {    'use strict';    angular.module('SerialFlowBuilder', [])        .factory('SerialFlowService', function () {            var getEndPointParams = function (param, originalEntity) {                if (typeof param === 'string') {                    return originalEntity[param];                } else {                    var parameters = {};                    for (var i = 0; i < param.length; i++) {                        parameters[param[i]] = originalEntity[param[i]];                    }                    return parameters;                }            };            var getEndPointResults = function (results) {                if (results.hasOwnProperty('total')) {                    return results.results;                } else {                    return [results];                }            };            /**             *             * @param entityList - Array list of objects to loop through.             * @param index - Index of the entity being executed. Must be initialised to 0.             * @param taskList - List of javascript functions to execute for each of the entities.             *                  If given as an object, it will look for the following:             *                  endpoint: should be a function if nested API call, or the string name of the entity to parse if nested arrayList,             *                  root: name of the entity where the data will be put against in the result,             *                  params: Any param to give to the Api call             *                  taskList: the list of task to execute for the given entity             * @param successHandler             */            var serialiseEntityParsing = function (entityList, index, taskList, successHandler) {                if (index < entityList.length) {                    serialiseTaskParsing({}, entityList[index], 0, taskList, function (entity) {                        entityList[index] = entity;                        serialiseEntityParsing(entityList, index + 1, taskList, successHandler);                    });                } else {                    successHandler(entityList);                }            };            var serialiseTaskParsing = function (entity, originalEntity, index, taskList, successHandler) {                if (index < taskList.length) {                    if (typeof taskList[index] === 'function') {                        entity = taskList[index](entity, originalEntity);                        serialiseTaskParsing(entity, originalEntity, index + 1, taskList, successHandler);                    } else {                        var task = taskList[index];                        if (typeof task.endpoint === 'function') {                            var params = getEndPointParams(task.params, originalEntity);                            task.endpoint(function (result) {                                var data = getEndPointResults(result);                                serialiseEntityParsing(data, 0, task.taskList, function (result) {                                    entity[task.root] = result[0];                                    serialiseTaskParsing(entity, originalEntity, index + 1, taskList, successHandler);                                });                            }, {}, params);                        } else {                            serialiseEntityParsing(originalEntity[task.endpoint], 0, task.taskList, function (result) {                                entity[task.endpoint] = result;                                serialiseTaskParsing(entity, originalEntity, index + 1, taskList, successHandler);                            });                        }                    }                } else {                    successHandler(entity);                }            };            return {                serialiseEntityParsing: serialiseEntityParsing            };        });});